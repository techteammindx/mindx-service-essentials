1. Audit existing specs and environment toggles in `docs/brainstorm/2025-10-25` and `.env.compose` to anchor the ping counter scope. Acceptance criteria: Notes captured confirming scope boundaries and active feature flags.
2. Define a `PingCounter` aggregate under `src/domain/ping` with repository port in `src/application`. Acceptance criteria: Aggregate exposes read model plus an increment method enforcing invariants, all covered by unit tests.
3. Implement Mongo and Postgres adapters in `src/infrastructure/persistence/ping` selected by `PERSISTENCE_DRIVER`. Acceptance criteria: Switching the flag boots the matching TypeORM DataSource without runtime errors.
4. Create an application service orchestrating repository reads and publishing `PingEvent` via a Kafka port under `src/application/services`. Acceptance criteria: Service logs the pre-increment snapshot and emits a Kafka message containing counter metadata.
5. Expose GraphQL resolver and gRPC controller wired through `TRANSPORT_MODE`, reusing DTOs from `src/application/dto`. Acceptance criteria: Both transports return identical payloads in local smoke tests.
6. Register a Kafka consumer within the Nest service to handle `PingEvent` and persist the incremented counter. Acceptance criteria: Consumer updates the counter and timestamps exactly once per event.
7. Add Vitest and transport integration coverage validating repository wiring, Kafka round-trip, and transport parity. Acceptance criteria: Test suite fails before implementation and passes afterward.
8. Prepare deployment configs in `docker/docker-compose.yaml`, ensure `docker/Dockerfile` builds the service image, and update `.env.compose` to expose new toggles and bootstrap scripts. Acceptance criteria: `docker compose up` builds the Dockerfile and starts all services with ping functionality reachable.
